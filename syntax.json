{
    "print_string": {
        "type": "function",
        "pattern": "print\\(\"(.*)\"\\);",
        "replacement": "println!(\"{}\", \"\\1\");"
    },
    "print_number": {
        "type": "function",
        "pattern": "print\\((\\d+)\\);",
        "replacement": "println!(\"{}\", \\1);"
    },
    "var_string": {
        "type": "variable",
        "pattern": "let (\\w+) = \"(.*)\";",
        "replacement": "let \\1 = String::from(\"\\2\");"
    },
    "var_number": {
        "type": "variable",
        "pattern": "let (\\w+) = (\\d+);",
        "replacement": "let \\1 = \\2;"
    },
    "ref": {
        "type": "input",
        "pattern": "ref (\\w+) >> (\\w+);",
        "replacement": "std::io::stdin().read_line(&mut \\2).unwrap();"
    },
    "int": {
        "type": "function",
        "pattern": "^\\s*int\\s+(\\w+)\\s*\\(\\)\\s*\\{\\s*$",
        "replacement": "fn \\1() {"
    },
    "whee_marker": {
        "type": "meta",
        "pattern": "^=== WHEE ===$",
        "replacement": "// Whee"
    },
    "empty_line": {
        "type": "meta",
        "pattern": "^\\s*$",
        "replacement": ""
    },
    "closing_brace": {
        "type": "syntax",
        "pattern": "^\\}$",
        "replacement": "}"
    },
    "call": {
        "type": "call",
        "pattern": "^\\s*call\\s+(\\w+)\\s*;\\s*$",
        "replacement": "\\1();"
    },
    "rust_cmd": {
        "type": "meta",
        "pattern": "^\\s*-(.*)$",
        "replacement": "\\1"
    },
    "if": {
        "type": "control",
        "pattern": "^\\s*if\\s+\\((.*?)\\)\\s*\\{\\s*$",
        "replacement": "if \\1 {"
    },
    "else": {
        "type": "control",
        "pattern": "^\\s*else\\s*\\{\\s*$",
        "replacement": "else {"
    },
    "for_loop": {
        "type": "loop",
        "pattern": "^\\s*for\\s+(\\w+)\\s+in\\s+(\\w+)\\s*\\{\\s*$",
        "replacement": "for \\1 in \\2 {"
    },
    "while_loop": {
        "type": "loop",
        "pattern": "^\\s*while\\s+\\((.*?)\\)\\s*\\{\\s*$",
        "replacement": "while \\1 {"
    },
    "comment_hash": {
        "type": "meta",
        "pattern": "^\\s*#(.*)$",
        "replacement": "// \\1"
    },
    "import_rust_std": {
        "type": "meta",
        "pattern": "^\\s*importrs\\s+(std::[\\w:]+);\\s*$",
        "replacement": "use \\1;"
    },
    "import_rust_alias": {
        "type": "meta",
        "pattern": "^\\s*importrs\\s+(std::[\\w:]+)\\s+as\\s+(\\w+);\\s*$",
        "replacement": "use \\1 as \\2;"
    },
    "add_numbers": {
        "type": "math",
        "pattern": "^\\s*add\\s+(\\d+)\\s+and\\s+(\\d+)\\s+>>\\s+(\\w+);$",
        "replacement": "let \\3 = \\1 + \\2;"
    },
    "return": {
        "type": "function",
        "pattern": "^\\s*return\\s+(.*);$",
        "replacement": "return \\1;"
    },
    "thread_block": {
        "type": "meta",
        "pattern": "^\\s*thread\\s+(\\w+)\\s*\\{\\s*$",
        "replacement": "let \\1 = std::thread::spawn(|| {"
    },
    "thread_end": {
        "type": "meta",
        "pattern": "^\\s*endthread\\s*$",
        "replacement": "});"
    },

    // === NEWLY ADDED ===
    "get_args_vec": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*args\\(\\)\\s*;\\s*$",
        "replacement": "let \\1 = std::env::args().collect::<Vec<String>>();"
    },
    "get_arg": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*args\\[(\\d+)\\];\\s*$",
        "replacement": "let \\1 = &args[\\2];"
    },
    "split_package_version": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*(\\w+)\\.split\\(\"@\"\\)\\.collect\\(\\);\\s*$",
        "replacement": "let \\1: Vec<&str> = \\2.split('@').collect();"
    },
    "package_id_extract": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*(\\w+)\\[(\\d+)\\];\\s*$",
        "replacement": "let \\1 = \\2[\\3];"
    },
    "package_version_fallback": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*if\\s+\\(\\w+\\.len\\(\\)\\s*>\\s*1\\)\\s*\\{\\s*(\\w+)\\[(\\d+)\\]\\s*\\}\\s*else\\s*\\{\\s*\"\"\\s*\\};\\s*$",
        "replacement": "let \\1 = if \\2.len() > 1 { \\2[\\3] } else { \"\" };"
    },
    "command_fmt": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*format!\\(\"(.*?)\",\\s*(.*?)\\);\\s*$",
        "replacement": "let \\1 = format!(\"\\2\", \\3);"
    },
    "curl_command": {
        "type": "function",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*Command::new\\(\"curl\"\\)\\.arg\\(\"(.*?)\"\\)\\.arg\\(&?(\\w+)\\)\\.output\\(\\)\\.unwrap\\(\\);$",
        "replacement": "let \\1 = Command::new(\"curl\").arg(\"\\2\").arg(&\\3).output().unwrap();"
    },
    "string_from_utf8": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*String::from_utf8_lossy\\(&\\s*(\\w+)\\.stdout\\);$",
        "replacement": "let \\1 = String::from_utf8_lossy(&\\2.stdout);"
    },
    "for_each_line": {
        "type": "loop",
        "pattern": "^\\s*for\\s+(\\w+)\\s+in\\s+(\\w+)\\.lines\\(\\)\\s*\\{\\s*$",
        "replacement": "for \\1 in \\2.lines() {"
    },
    "string_replace_trim": {
        "type": "variable",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*\\1\\.replace\\(\"(.*?)\",\\s*\"\"\\)\\.trim\\(\\)\\.to_string\\(\\);$",
        "replacement": "let \\1 = \\1.replace(\"\\2\", \"\").trim().to_string();"
    },
    "file_create": {
        "type": "function",
        "pattern": "^\\s*let\\s+(\\w+)\\s*=\\s*File::create\\(&?(\\w+)\\)\\.unwrap\\(\\);$",
        "replacement": "let \\1 = File::create(&\\2).unwrap();"
    },
    "file_write": {
        "type": "function",
        "pattern": "^\\s*\\w+\\.write_all\\(&?(\\w+)\\.stdout\\)\\.unwrap\\(\\);$",
        "replacement": "\\0"
    },
    "fs_create_dir": {
        "type": "function",
        "pattern": "^\\s*let\\s+_\\s*=\\s*fs::create_dir_all\\(&?(\\w+)\\);$",
        "replacement": "let _ = fs::create_dir_all(&\\1);"
    },
    "cmd_status": {
        "type": "function",
        "pattern": "^\\s*let\\s+_\\s*=\\s*Command::new\\(\"(.*?)\"\\)(.*?)\\.status\\(\\);$",
        "replacement": "let _ = Command::new(\"\\1\")\\2.status();"
    },
    "path_exists": {
        "type": "condition",
        "pattern": "^\\s*if\\s+std::path::Path::new\\(&?(\\w+)\\)\\.exists\\(\\)\\s*\\{\\s*$",
        "replacement": "if std::path::Path::new(&\\1).exists() {"
    }
}
